{"version":3,"sources":["../src/utils/common/utils.constants.ts","../src/utils/crypto/crypto.constants.ts","../src/utils/crypto/crypto.utils.ts","../src/utils/key/key-constants.ts","../src/utils/key/key.utils.ts","../src/index.ts"],"sourcesContent":["export const AES_KEY_SIZE = 32; // 256 bits","// AES encryption parameters\nexport const AES_256_GCM_ALGORITHM = 'aes-256-gcm'; // AES algorithm\nexport const AES_IV_SIZE = 12; // 96 bits\nexport const AES_TAG_SIZE = 16; // 128 bits\nexport const SALT_SIZE = 16; // 128 bits\n// Argon2 parameters\nexport const ARGON2_HASH_LENGTH = 32; // 256 bits\nexport const ARGON2_MEMORY = 65536; // 64 MB\n// Encoding formats\nexport const BASE64_ENCODING = 'base64';\nexport const UTF8_ENCODING = 'utf8';\nexport const HEX_ENCODING = 'hex';","/**\n * @file crypto.utils.ts\n * @description Utility functions for cryptographic operations, including AES encryption/decryption and Argon2 key derivation.\n */\n\nimport argon2 from \"argon2\";\nimport crypto, { type BinaryLike } from \"node:crypto\";\n\nimport {\n  AES_256_GCM_ALGORITHM,\n  AES_IV_SIZE,\n  AES_TAG_SIZE,\n  ARGON2_HASH_LENGTH,\n  HEX_ENCODING,\n  SALT_SIZE,\n} from \"./crypto.constants\";\n\nimport type { EncryptedKeyData } from \"../common/utils.types\";\nimport { AES_KEY_SIZE } from \"../common/utils.constants\";\n\n/**\n * Generates a buffer of random bytes of the specified size.\n *\n * @param size - The number of random bytes to generate.\n * @returns A Buffer containing the random bytes.\n */\nexport const getRandomBytes = (size: number): Buffer => {\n  return crypto.randomBytes(size);\n};\n\n/**\n * Converts a Buffer to a hexadecimal string.\n *\n * @param buffer - The Buffer to convert.\n * @returns A string representing the hexadecimal encoding of the buffer.\n */\nexport const convertToHex = (buffer: Buffer): string => {\n  return buffer.toString(HEX_ENCODING);\n};\n\n/**\n * Generates an encrypted AES key using a password.\n *\n * @param password - The password used to derive the encryption key.\n * @returns A promise that resolves to the encrypted key parameters.\n */\nexport const generateEncryptedKeyData = async (\n  password: string\n): Promise<EncryptedKeyData> => {\n  const aesKey = getRandomBytes(AES_KEY_SIZE);\n  const salt = getRandomBytes(SALT_SIZE);\n\n  const derivedKey = await argon2.hash(password, {\n    salt,\n    type: argon2.argon2id,\n    hashLength: ARGON2_HASH_LENGTH,\n    raw: true,\n  });\n\n  const iv = getRandomBytes(AES_IV_SIZE);\n  const cipher = crypto.createCipheriv(AES_256_GCM_ALGORITHM, derivedKey, iv);\n  const encryptedKey = Buffer.concat([cipher.update(aesKey), cipher.final()]);\n  const tag = cipher.getAuthTag();\n\n  const encryptedKeyData: EncryptedKeyData = {\n    encryptedKey: encryptedKey.toString(HEX_ENCODING),\n    salt: salt.toString(HEX_ENCODING),\n    iv: iv.toString(HEX_ENCODING),\n    tag: tag.toString(HEX_ENCODING),\n  };\n\n  return encryptedKeyData;\n};\n\n/**\n * Decrypts an encrypted AES key using a password and key parameters.\n *\n * @param password - The password used to derive the decryption key.\n * @param keyData - The parameters containing the encrypted key, salt, IV, and tag.\n * @returns A promise that resolves to the decrypted AES key as a Buffer.\n */\nexport const decryptKeyData = async (\n  password: string,\n  keyData: EncryptedKeyData\n): Promise<Buffer> => {\n  const { encryptedKey, salt, iv, tag } = keyData;\n\n  const derivedKey = await argon2.hash(password, {\n    salt: Buffer.from(salt, HEX_ENCODING),\n    type: argon2.argon2id,\n    hashLength: ARGON2_HASH_LENGTH,\n    raw: true,\n  });\n\n  const decipher = crypto.createDecipheriv(\n    AES_256_GCM_ALGORITHM,\n    derivedKey,\n    Buffer.from(iv, HEX_ENCODING)\n  );\n\n  decipher.setAuthTag(Buffer.from(tag, HEX_ENCODING));\n\n  const decryptedKey = Buffer.concat([\n    decipher.update(Buffer.from(encryptedKey, HEX_ENCODING)),\n    decipher.final(),\n  ]);\n\n  return decryptedKey;\n};\n\n/**\n * Encrypts data using an AES key.\n *\n * @param aesKey - The AES key used for encryption.\n * @param data - The data to be encrypted.\n * @returns A Buffer containing the IV, authentication tag, and encrypted data.\n */\nexport const encrypt = (\n  aesKey: string,\n  data: BinaryLike\n): Buffer => {\n  const iv = getRandomBytes(AES_IV_SIZE);\n  const cipher = crypto.createCipheriv(AES_256_GCM_ALGORITHM, aesKey, iv);\n  const encrypted = Buffer.concat([cipher.update(data), cipher.final()]);\n  const tag = cipher.getAuthTag();\n\n  return Buffer.concat([iv, tag, encrypted]);\n};\n\n/**\n * Decrypts data using an AES key.\n *\n * @param aesKey - The AES key used for decryption.\n * @param data - The Buffer containing the IV, authentication tag, and encrypted data.\n * @returns A Buffer containing the decrypted data.\n */\nexport const decrypt = (aesKey: string, data: Buffer): Buffer => {\n  const iv = data.subarray(0, AES_IV_SIZE);\n  const tag = data.subarray(AES_IV_SIZE, AES_IV_SIZE + AES_TAG_SIZE);\n  const encrypted = data.subarray(AES_IV_SIZE + AES_TAG_SIZE);\n\n  const decipher = crypto.createDecipheriv(AES_256_GCM_ALGORITHM, aesKey, iv);\n  decipher.setAuthTag(tag);\n\n  const decrypted = Buffer.concat([\n    decipher.update(encrypted),\n    decipher.final(),\n  ]);\n\n  return decrypted;\n};\n","// Folder to store key files\nexport const VAULT_DIR_NAME = '.vault';\n// Name of the key file\nexport const KEY_FILE_EXTENSION = '.json';\nexport const KEY_FILE_PREFIX_NAME = 'biory-key';\n// Version of the key file\nexport const KEY_VERSION = 1;\n","import * as fs from \"node:fs\";\nimport path from \"node:path\";\nimport { AES_KEY_SIZE } from \"../common/utils.constants\";\nimport type { EncryptedKeyData } from \"../common/utils.types\";\nimport { UTF8_ENCODING } from \"../crypto/crypto.constants\";\nimport {\n  convertToHex,\n  decryptKeyData,\n  generateEncryptedKeyData,\n  getRandomBytes,\n} from \"../crypto/crypto.utils\";\nimport {\n  KEY_FILE_EXTENSION,\n  KEY_FILE_PREFIX_NAME,\n  VAULT_DIR_NAME,\n} from \"./key-constants\";\nimport type {\n  EncryptedKeyFileData,\n  GeneratedEncryptedKeyFileData,\n} from \"./key.types\";\n\nconst VAULT_DIR = path.join(__dirname, \"../\", VAULT_DIR_NAME);\n\nconst getKeyFilePathByUsername = (username: string): string => {\n  const fileName = `${username}-${KEY_FILE_PREFIX_NAME}${KEY_FILE_EXTENSION}`;\n  return path.join(VAULT_DIR, fileName);\n};\n\nconst createVaultDirectoryIfRequired = (): void => {\n  if (!fs.existsSync(VAULT_DIR)) {\n    fs.mkdirSync(VAULT_DIR);\n  }\n\n  console.log(`Biory App: Vault directory created at ${VAULT_DIR}`);\n};\n\nconst generateRecoveryCodeString = (): string => {\n  const randomBytes = getRandomBytes(AES_KEY_SIZE);\n  return convertToHex(randomBytes);\n};\n\nexport const setupEncryptedKeyFileData = async (\n  username: string,\n  password: string\n): Promise<GeneratedEncryptedKeyFileData | null> => {\n  createVaultDirectoryIfRequired();\n\n  const passwordKey = await generateEncryptedKeyData(password);\n  const recoveryCodeHex = generateRecoveryCodeString();\n  const recoveryKey = await generateEncryptedKeyData(recoveryCodeHex);\n\n  const keyFilePath = getKeyFilePathByUsername(username);\n\n  if (fs.existsSync(keyFilePath)) {\n    console.log(\n      `Biory key file already exists: ${keyFilePath}, delete existing file to create a new one.`\n    );\n    return null;\n  }\n\n  const encryptedKeyFileData: EncryptedKeyFileData = {\n    username,\n    passwordKey,\n    recoveryKey,\n  };\n\n  fs.writeFileSync(keyFilePath, JSON.stringify(encryptedKeyFileData, null, 2));\n\n  console.log(`Biory key saved: ${keyFilePath}`);\n\n  return {\n    ...encryptedKeyFileData,\n    recoveryCode: recoveryCodeHex,\n  } as GeneratedEncryptedKeyFileData;\n};\n\nexport const unlockEncryptedKey = async (\n  username: string,\n  password: string\n): Promise<Buffer<ArrayBuffer>> => {\n  const keyFilePath = getKeyFilePathByUsername(username);\n  const keyFileContent = fs.readFileSync(keyFilePath, UTF8_ENCODING);\n  const encryptedKeyData: EncryptedKeyData = JSON.parse(keyFileContent);\n\n  return decryptKeyData(password, encryptedKeyData);\n};\n","import { setupEncryptedKeyFileData } from \"@key-utils/key.utils\";\n\nconsole.log('Biory App v0.0.1')\n\nconst setupEncryptedKeyFileDataExe = async () => {\n  await setupEncryptedKeyFileData(\n    'axel',\n    'password',\n  );\n};\n\nsetupEncryptedKeyFileDataExe();"],"mappings":"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","names":[]}