{"version":3,"sources":["../src/utils/key/key.utils.ts","../src/utils/common/utils.constants.ts","../src/utils/crypto/crypto.constants.ts","../src/utils/crypto/crypto.utils.ts","../src/utils/key/key-constants.ts","../src/index.ts"],"sourcesContent":["import * as fs from \"node:fs\";\nimport path from \"node:path\";\nimport { AES_KEY_SIZE } from \"../common/utils.constants\";\nimport type { EncryptedKeyData } from \"../common/utils.types\";\nimport { UTF8_ENCODING } from \"../crypto/crypto.constants\";\nimport {\n  convertToHex,\n  decryptKeyData,\n  generateEncryptedKeyData,\n  getRandomBytes,\n} from \"../crypto/crypto.utils\";\nimport {\n  KEY_FILE_EXTENSION,\n  KEY_FILE_PREFIX_NAME,\n  VAULT_DIR_NAME,\n} from \"./key-constants\";\nimport type {\n  EncryptedKeyFileData,\n  GeneratedEncryptedKeyFileData,\n} from \"./key.types\";\n\nconst VAULT_DIR = path.join(__dirname, \"../\", VAULT_DIR_NAME);\n\nconst getKeyFilePathByUsername = (username: string): string => {\n  const fileName = `${username}-${KEY_FILE_PREFIX_NAME}${KEY_FILE_EXTENSION}`;\n  return path.join(VAULT_DIR, fileName);\n};\n\nconst createVaultDirectoryIfRequired = (): void => {\n  if (!fs.existsSync(VAULT_DIR)) {\n    fs.mkdirSync(VAULT_DIR);\n  }\n\n  console.log(`Biory App: Vault directory created at ${VAULT_DIR}`);\n};\n\nconst generateRecoveryCodeString = (): string => {\n  const randomBytes = getRandomBytes(AES_KEY_SIZE);\n  return convertToHex(randomBytes);\n};\n\nexport const setupEncryptedKeyFileData = async (\n  username: string,\n  password: string\n): Promise<GeneratedEncryptedKeyFileData | null> => {\n  createVaultDirectoryIfRequired();\n\n  const passwordKey = await generateEncryptedKeyData(password);\n  const recoveryCodeHex = generateRecoveryCodeString();\n  const recoveryKey = await generateEncryptedKeyData(recoveryCodeHex);\n\n  const keyFilePath = getKeyFilePathByUsername(username);\n\n  if (fs.existsSync(keyFilePath)) {\n    console.log(\n      `Biory key file already exists: ${keyFilePath}, delete existing file to create a new one.`\n    );\n    return null;\n  }\n\n  const encryptedKeyFileData: EncryptedKeyFileData = {\n    username,\n    passwordKey,\n    recoveryKey,\n  };\n\n  fs.writeFileSync(keyFilePath, JSON.stringify(encryptedKeyFileData, null, 2));\n\n  console.log(`Biory key saved: ${keyFilePath}`);\n\n  return {\n    ...encryptedKeyFileData,\n    recoveryCode: recoveryCodeHex,\n  } as GeneratedEncryptedKeyFileData;\n};\n\nexport const unlockEncryptedKey = async (\n  username: string,\n  password: string\n): Promise<Buffer<ArrayBuffer>> => {\n  const keyFilePath = getKeyFilePathByUsername(username);\n  const keyFileContent = fs.readFileSync(keyFilePath, UTF8_ENCODING);\n  const encryptedKeyData: EncryptedKeyData = JSON.parse(keyFileContent);\n\n  return decryptKeyData(password, encryptedKeyData);\n};\n","export const AES_KEY_SIZE = 32; // 256 bits","// AES encryption parameters\nexport const AES_256_GCM_ALGORITHM = 'aes-256-gcm'; // AES algorithm\nexport const AES_IV_SIZE = 12; // 96 bits\nexport const AES_TAG_SIZE = 16; // 128 bits\nexport const SALT_SIZE = 16; // 128 bits\n// Argon2 parameters\nexport const ARGON2_HASH_LENGTH = 32; // 256 bits\nexport const ARGON2_MEMORY = 65536; // 64 MB\n// Encoding formats\nexport const BASE64_ENCODING = 'base64';\nexport const UTF8_ENCODING = 'utf8';\nexport const HEX_ENCODING = 'hex';","/**\n * @file crypto.utils.ts\n * @description Utility functions for cryptographic operations, including AES encryption/decryption and Argon2 key derivation.\n */\n\nimport argon2 from \"argon2\";\nimport crypto, { type BinaryLike } from \"node:crypto\";\n\nimport {\n  AES_256_GCM_ALGORITHM,\n  AES_IV_SIZE,\n  AES_TAG_SIZE,\n  ARGON2_HASH_LENGTH,\n  HEX_ENCODING,\n  SALT_SIZE,\n} from \"./crypto.constants\";\n\nimport type { EncryptedKeyData } from \"../common/utils.types\";\nimport { AES_KEY_SIZE } from \"../common/utils.constants\";\n\n/**\n * Generates a buffer of random bytes of the specified size.\n *\n * @param size - The number of random bytes to generate.\n * @returns A Buffer containing the random bytes.\n */\nexport const getRandomBytes = (size: number): Buffer => {\n  return crypto.randomBytes(size);\n};\n\n/**\n * Converts a Buffer to a hexadecimal string.\n *\n * @param buffer - The Buffer to convert.\n * @returns A string representing the hexadecimal encoding of the buffer.\n */\nexport const convertToHex = (buffer: Buffer): string => {\n  return buffer.toString(HEX_ENCODING);\n};\n\n/**\n * Generates an encrypted AES key using a password.\n *\n * @param password - The password used to derive the encryption key.\n * @returns A promise that resolves to the encrypted key parameters.\n */\nexport const generateEncryptedKeyData = async (\n  password: string\n): Promise<EncryptedKeyData> => {\n  const aesKey = getRandomBytes(AES_KEY_SIZE);\n  const salt = getRandomBytes(SALT_SIZE);\n\n  const derivedKey = await argon2.hash(password, {\n    salt,\n    type: argon2.argon2id,\n    hashLength: ARGON2_HASH_LENGTH,\n    raw: true,\n  });\n\n  const iv = getRandomBytes(AES_IV_SIZE);\n  const cipher = crypto.createCipheriv(AES_256_GCM_ALGORITHM, derivedKey, iv);\n  const encryptedKey = Buffer.concat([cipher.update(aesKey), cipher.final()]);\n  const tag = cipher.getAuthTag();\n\n  const encryptedKeyData: EncryptedKeyData = {\n    encryptedKey: encryptedKey.toString(HEX_ENCODING),\n    salt: salt.toString(HEX_ENCODING),\n    iv: iv.toString(HEX_ENCODING),\n    tag: tag.toString(HEX_ENCODING),\n  };\n\n  return encryptedKeyData;\n};\n\n/**\n * Decrypts an encrypted AES key using a password and key parameters.\n *\n * @param password - The password used to derive the decryption key.\n * @param keyData - The parameters containing the encrypted key, salt, IV, and tag.\n * @returns A promise that resolves to the decrypted AES key as a Buffer.\n */\nexport const decryptKeyData = async (\n  password: string,\n  keyData: EncryptedKeyData\n): Promise<Buffer> => {\n  const { encryptedKey, salt, iv, tag } = keyData;\n\n  const derivedKey = await argon2.hash(password, {\n    salt: Buffer.from(salt, HEX_ENCODING),\n    type: argon2.argon2id,\n    hashLength: ARGON2_HASH_LENGTH,\n    raw: true,\n  });\n\n  const decipher = crypto.createDecipheriv(\n    AES_256_GCM_ALGORITHM,\n    derivedKey,\n    Buffer.from(iv, HEX_ENCODING)\n  );\n\n  decipher.setAuthTag(Buffer.from(tag, HEX_ENCODING));\n\n  const decryptedKey = Buffer.concat([\n    decipher.update(Buffer.from(encryptedKey, HEX_ENCODING)),\n    decipher.final(),\n  ]);\n\n  return decryptedKey;\n};\n\n/**\n * Encrypts data using an AES key.\n *\n * @param aesKey - The AES key used for encryption.\n * @param data - The data to be encrypted.\n * @returns A Buffer containing the IV, authentication tag, and encrypted data.\n */\nexport const encrypt = (\n  aesKey: string,\n  data: BinaryLike\n): Buffer => {\n  const iv = getRandomBytes(AES_IV_SIZE);\n  const cipher = crypto.createCipheriv(AES_256_GCM_ALGORITHM, aesKey, iv);\n  const encrypted = Buffer.concat([cipher.update(data), cipher.final()]);\n  const tag = cipher.getAuthTag();\n\n  return Buffer.concat([iv, tag, encrypted]);\n};\n\n/**\n * Decrypts data using an AES key.\n *\n * @param aesKey - The AES key used for decryption.\n * @param data - The Buffer containing the IV, authentication tag, and encrypted data.\n * @returns A Buffer containing the decrypted data.\n */\nexport const decrypt = (aesKey: string, data: Buffer): Buffer => {\n  const iv = data.subarray(0, AES_IV_SIZE);\n  const tag = data.subarray(AES_IV_SIZE, AES_IV_SIZE + AES_TAG_SIZE);\n  const encrypted = data.subarray(AES_IV_SIZE + AES_TAG_SIZE);\n\n  const decipher = crypto.createDecipheriv(AES_256_GCM_ALGORITHM, aesKey, iv);\n  decipher.setAuthTag(tag);\n\n  const decrypted = Buffer.concat([\n    decipher.update(encrypted),\n    decipher.final(),\n  ]);\n\n  return decrypted;\n};\n","// Folder to store key files\nexport const VAULT_DIR_NAME = '.vault';\n// Name of the key file\nexport const KEY_FILE_EXTENSION = '.json';\nexport const KEY_FILE_PREFIX_NAME = 'biory-key';\n// Version of the key file\nexport const KEY_VERSION = 1;\n","import { setupEncryptedKeyFileData } from \"@key-utils/key.utils\";\n\nconsole.log('Biory App v0.0.1')\n\nconst setupEncryptedKeyFileDataExe = async () => {\n  await setupEncryptedKeyFileData(\n    'axel',\n    'password',\n  );\n};\n\nsetupEncryptedKeyFileDataExe();"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;AAAA,SAAoB;AACpB,uBAAiB;;;ACDV,IAAM,eAAe;;;ACCrB,IAAM,wBAAwB;AAC9B,IAAM,cAAc;AAEpB,IAAM,YAAY;AAElB,IAAM,qBAAqB;AAK3B,IAAM,eAAe;;;ACN5B,oBAAmB;AACnB,yBAAwC;AAoBjC,IAAM,iBAAiB,CAAC,SAAyB;AACtD,SAAO,mBAAAA,QAAO,YAAY,IAAI;AAChC;AAQO,IAAM,eAAe,CAAC,WAA2B;AACtD,SAAO,OAAO,SAAS,YAAY;AACrC;AAQO,IAAM,2BAA2B,OACtC,aAC8B;AAC9B,QAAM,SAAS,eAAe,YAAY;AAC1C,QAAM,OAAO,eAAe,SAAS;AAErC,QAAM,aAAa,MAAM,cAAAC,QAAO,KAAK,UAAU;AAAA,IAC7C;AAAA,IACA,MAAM,cAAAA,QAAO;AAAA,IACb,YAAY;AAAA,IACZ,KAAK;AAAA,EACP,CAAC;AAED,QAAM,KAAK,eAAe,WAAW;AACrC,QAAM,SAAS,mBAAAD,QAAO,eAAe,uBAAuB,YAAY,EAAE;AAC1E,QAAM,eAAe,OAAO,OAAO,CAAC,OAAO,OAAO,MAAM,GAAG,OAAO,MAAM,CAAC,CAAC;AAC1E,QAAM,MAAM,OAAO,WAAW;AAE9B,QAAM,mBAAqC;AAAA,IACzC,cAAc,aAAa,SAAS,YAAY;AAAA,IAChD,MAAM,KAAK,SAAS,YAAY;AAAA,IAChC,IAAI,GAAG,SAAS,YAAY;AAAA,IAC5B,KAAK,IAAI,SAAS,YAAY;AAAA,EAChC;AAEA,SAAO;AACT;;;ACvEO,IAAM,iBAAiB;AAEvB,IAAM,qBAAqB;AAC3B,IAAM,uBAAuB;;;AJiBpC,IAAM,YAAY,iBAAAE,QAAK,KAAK,WAAW,OAAO,cAAc;AAE5D,IAAM,2BAA2B,CAAC,aAA6B;AAC7D,QAAM,WAAW,GAAG,QAAQ,IAAI,oBAAoB,GAAG,kBAAkB;AACzE,SAAO,iBAAAA,QAAK,KAAK,WAAW,QAAQ;AACtC;AAEA,IAAM,iCAAiC,MAAY;AACjD,MAAI,CAAI,cAAW,SAAS,GAAG;AAC7B,IAAG,aAAU,SAAS;AAAA,EACxB;AAEA,UAAQ,IAAI,yCAAyC,SAAS,EAAE;AAClE;AAEA,IAAM,6BAA6B,MAAc;AAC/C,QAAM,cAAc,eAAe,YAAY;AAC/C,SAAO,aAAa,WAAW;AACjC;AAEO,IAAM,4BAA4B,OACvC,UACA,aACkD;AAClD,iCAA+B;AAE/B,QAAM,cAAc,MAAM,yBAAyB,QAAQ;AAC3D,QAAM,kBAAkB,2BAA2B;AACnD,QAAM,cAAc,MAAM,yBAAyB,eAAe;AAElE,QAAM,cAAc,yBAAyB,QAAQ;AAErD,MAAO,cAAW,WAAW,GAAG;AAC9B,YAAQ;AAAA,MACN,kCAAkC,WAAW;AAAA,IAC/C;AACA,WAAO;AAAA,EACT;AAEA,QAAM,uBAA6C;AAAA,IACjD;AAAA,IACA;AAAA,IACA;AAAA,EACF;AAEA,EAAG,iBAAc,aAAa,KAAK,UAAU,sBAAsB,MAAM,CAAC,CAAC;AAE3E,UAAQ,IAAI,oBAAoB,WAAW,EAAE;AAE7C,SAAO;AAAA,IACL,GAAG;AAAA,IACH,cAAc;AAAA,EAChB;AACF;;;AKxEA,QAAQ,IAAI,kBAAkB;AAE9B,IAAM,+BAA+B,YAAY;AAC/C,QAAM;AAAA,IACJ;AAAA,IACA;AAAA,EACF;AACF;AAEA,6BAA6B;","names":["crypto","argon2","path"]}